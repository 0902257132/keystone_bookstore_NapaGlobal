import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import { Relationship } from '@keystonejs/fields';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

class AuthedRelationship extends Relationship.implementation {
  constructor(path, config, meta) {
    let access;

    if (typeof config.access === 'object') {
      access = config.access;
    } else if (typeof config.access !== 'undefined') {
      access = {
        create: config.access,
        read: config.access,
        update: config.access
      };
    }

    access = _objectSpread(_objectSpread({}, {
      create: false,
      read: true,
      update: false
    }), access);
    super(path, _objectSpread(_objectSpread({}, config), {}, {
      access
    }), meta);

    if (typeof this.defaultValue !== 'undefined') {
      throw new Error(`An AuthedRelationship field's default is derived from the currently authenticated item. Try removing 'defaultValue: ...' from ${this.listKey}.${this.path}`);
    }

    if (this.many) {
      throw new Error(`An AuthedRelationship field can only be to-single, not to-many. Try removing 'many: true' from ${this.listKey}.${this.path}`);
    } // Reset this so there are no core-level isRequired checks run. We'll handle
    // them ourselves with this.isRequiredOnCreate


    this.isRequiredOnCreate = this.isRequired;
    this.isRequired = false;

    this.defaultValue = ({
      context
    }) => {
      if (this.isRequiredOnCreate) {
        if (!context.authedListKey) {
          throw new Error(`An unauthenticated request attempted to create a new ${this.listKey} without specifying a value for ${this.listKey}.${this.path}<AuthenticatedRelationship>, however it is marked 'isRequired'.`);
        }

        if (context.authedListKey !== this.refListKey) {
          throw new Error(`${this.listKey}.${this.path}<AuthedRelationship> is marked as 'isRequired'`);
        }
      }

      if (context.authedListKey === this.refListKey && context.authedItem) {
        return {
          connect: {
            id: context.authedItem.id
          }
        };
      }

      return undefined;
    };
  }

}

function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$1(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const AuthedRelationship$1 = _objectSpread$1(_objectSpread$1({}, Relationship), {}, {
  type: 'AuthedRelationship',
  implementation: AuthedRelationship
});

export { AuthedRelationship$1 as AuthedRelationship };
