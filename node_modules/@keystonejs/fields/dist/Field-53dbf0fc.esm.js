import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import { jsx } from '@emotion/core';
import { FieldContainer, FieldLabel, FieldDescription, FieldInput } from '@arch-ui/fields';
import { useState } from 'react';
import _extends from '@babel/runtime/helpers/esm/extends';
import Select from '@arch-ui/select';
import { useToasts } from 'react-toast-notifications';
import { GoogleApiWrapper, Map, Marker } from 'google-maps-react';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const LocationField = ({
  field,
  value,
  errors,
  onChange,
  google,
  renderContext,
  isDisabled
}) => {
  const {
    googlePlaceID,
    formattedAddress,
    lat,
    lng
  } = _objectSpread({}, value);

  const htmlID = `ks-input-${field.path}`;
  const autocompleteService = new google.maps.places.AutocompleteService();
  const geocoder = new google.maps.Geocoder();
  const {
    addToast
  } = useToasts();
  const [inputValue, setInputValue] = useState(googlePlaceID ? {
    label: formattedAddress,
    value: googlePlaceID
  } : null);
  const [marker, setMarker] = useState(lat && lng ? {
    lat,
    lng
  } : null);

  const handleOptionChange = option => {
    if (!option) {
      onChange(null);
      setMarker(null);
      setInputValue(null);
      return;
    }

    const placeId = option.value;
    geocoder.geocode({
      placeId
    }, (results, status) => {
      if (status === 'OK') {
        if (results[0]) {
          const {
            formatted_address,
            geometry: {
              location: {
                lat,
                lng
              }
            }
          } = results[0];
          setInputValue({
            label: formatted_address,
            value: placeId
          });
          setMarker({
            lat: lat(),
            lng: lng()
          });
          onChange(placeId);
        }
      } else {
        addToast('Could not find the provided location.', {
          appearance: 'error',
          autoDismiss: true
        });
      }
    });
  };

  const loadOptions = inputValue => new Promise(resolve => {
    autocompleteService.getPlacePredictions({
      input: inputValue
    }, results => {
      if (results) {
        resolve(results.map(({
          description,
          place_id
        }) => ({
          label: description,
          value: place_id
        })));
      }

      resolve(null);
    });
  });

  const selectProps = renderContext === 'dialog' ? {
    menuPortalTarget: document.body,
    menuShouldBlockScroll: true
  } : null;
  return jsx(FieldContainer, null, jsx(FieldLabel, {
    htmlFor: htmlID,
    field: field,
    errors: errors
  }), jsx(FieldDescription, {
    text: field.adminDoc
  }), jsx(FieldInput, {
    css: {
      flexDirection: 'column'
    }
  }, jsx(Select, _extends({
    isAsync: true,
    isClearable: true,
    cacheOptions: true,
    placeholder: "Search for a location ...",
    value: inputValue,
    onChange: handleOptionChange,
    loadOptions: loadOptions,
    id: `react-select-${htmlID}`,
    inputId: htmlID,
    instanceId: htmlID,
    css: {
      width: '100%'
    },
    isDisabled: isDisabled
  }, selectProps)), marker && jsx("div", {
    css: {
      position: 'relative',
      height: '14rem',
      marginTop: '1rem'
    }
  }, jsx(Map, {
    google: google,
    initialCenter: marker,
    center: marker,
    zoom: 16
  }, jsx(Marker, {
    position: marker
  })))));
};

var Field = GoogleApiWrapper(props => ({
  apiKey: props.field.config.googleMapsKey
}))(LocationField);
export default Field;
